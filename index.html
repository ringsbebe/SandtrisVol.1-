<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sandtris - 秋日山景版</title>
    <style>
        body {
            /* 背景調整為極深的山林綠灰，比純黑更有氛圍 */
            background-color: #1e2120; 
            color: #dcd3cb;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none; 
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        h1 {
            margin: 5px 0 10px 0;
            font-size: 24px;
            color: #a8c686; /* 標題維持淡綠色，與背景協調 */
            text-shadow: 2px 2px 0px #0f1211;
            letter-spacing: 3px;
            font-weight: 300;
        }

        #main-layout {
            display: flex;
            flex-direction: row;
            gap: 20px;
            align-items: flex-start;
            justify-content: center;
            width: 100%;
            max-width: 800px;
        }

        #game-area {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #game-container {
            position: relative;
            border: 4px solid #3e4a42; /* 墨綠色邊框 */
            box-shadow: 0 0 30px rgba(0,0,0,0.6);
            background-color: #121413;
            height: 70vh; 
            aspect-ratio: 2 / 3;
            border-radius: 4px;
        }

        canvas#gameCanvas {
            display: block;
            background-color: #121413;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            outline: none;
            border-radius: 2px;
        }

        #sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 120px;
        }

        .panel {
            background-color: #2a302d; /* 深綠灰面板 */
            border: 1px solid #3e4a42;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }

        .panel h3 {
            margin: 0 0 5px 0;
            font-size: 12px;
            color: #7a8f80;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .panel span {
            font-size: 18px;
            font-weight: 500;
            color: #dcd3cb;
            display: block;
        }

        #sound-panel {
            cursor: pointer;
        }
        
        #sound-panel:hover {
            background-color: #353e39;
        }

        #sound-panel.active {
            border-color: #D16D5A; /* 開啟時顯示楓紅色 */
            background-color: #2e2524;
        }
        
        #sound-panel.active span {
            color: #D16D5A;
        }

        #nextCanvas {
            background-color: #121413;
            margin: 0 auto;
            display: block;
            border: 1px solid #2a302d;
            image-rendering: pixelated;
            max-width: 100%;
            border-radius: 4px;
        }

        #controls-hint {
            margin-top: 15px;
            font-size: 13px;
            color: #5a665e;
            text-align: center;
            width: 100%;
            font-weight: 300;
        }
        
        .key {
            display: inline-block;
            padding: 1px 6px;
            border: 1px solid #4a554e;
            border-radius: 4px;
            background: #2a302d;
            color: #b0c4b5;
            margin: 0 2px;
            font-family: monospace;
            font-size: 11px;
        }

        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(18, 20, 19, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            visibility: hidden;
            z-index: 10;
        }

        #game-over h2 {
            font-size: 32px;
            color: #D16D5A; /* 遊戲結束顯示楓紅 */
            margin: 0 0 20px 0;
            font-weight: 300;
            letter-spacing: 2px;
        }

        button {
            padding: 10px 25px;
            font-size: 16px;
            cursor: pointer;
            background: #D16D5A; /* 按鈕改為楓紅 */
            border: none;
            border-radius: 20px;
            font-weight: 600;
            color: #121413;
            transition: transform 0.2s, background 0.2s;
            letter-spacing: 1px;
        }

        button:hover {
            transform: scale(1.05);
            background: #E69A8D;
        }

        button:active {
            transform: scale(0.95);
        }

        #mobile-controls {
            display: none;
            flex-direction: row;
            gap: 20px;
            margin-top: 20px;
            width: 100%;
            justify-content: center;
        }

        .control-btn {
            background: rgba(168, 198, 134, 0.05);
            border: 1px solid rgba(168, 198, 134, 0.2);
            border-radius: 50%;
            width: 65px;
            height: 65px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: #a8c686;
            user-select: none;
            cursor: pointer;
            transition: background 0.2s;
        }

        .control-btn:active {
            background: rgba(168, 198, 134, 0.2);
            border-color: #a8c686;
            color: #fff;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 20px;
                margin-bottom: 5px;
            }

            #main-layout {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }

            #game-container {
                height: 55vh;
            }

            #sidebar {
                flex-direction: row;
                width: 100%;
                justify-content: center;
                gap: 12px;
            }

            .panel {
                padding: 5px;
                min-width: 65px;
            }
            
            .panel h3 {
                font-size: 11px;
            }
            
            .panel span {
                font-size: 15px;
            }

            #nextCanvas {
                width: 32px;
                height: 32px;
            }

            #controls-hint {
                display: none;
            }

            #mobile-controls {
                display: flex;
            }
        }
    </style>
</head>
<body>

    <h1>SANDTRIS</h1>

    <div id="main-layout">
        <div id="game-area">
            <div id="game-container">
                <canvas id="gameCanvas" tabindex="1"></canvas>
                <div id="game-over">
                    <h2>GAME OVER</h2>
                    <button onclick="resetGame()">AGAIN</button>
                </div>
            </div>
            
            <div id="mobile-controls">
                <div class="control-btn" id="btn-left">←</div>
                <div class="control-btn" id="btn-down">↓</div>
                <div class="control-btn" id="btn-right">→</div>
            </div>

            <div id="controls-hint">
                <span class="key">←</span> <span class="key">→</span> 移動 | 
                <span class="key">↓</span> 輕放
            </div>
        </div>

        <div id="sidebar">
            <div class="panel">
                <h3>Next</h3>
                <canvas id="nextCanvas" width="120" height="120"></canvas>
            </div>
            <div class="panel">
                <h3>Score</h3>
                <span id="score">0</span>
            </div>
            <div class="panel">
                <h3>Level</h3>
                <span id="level">1</span>
            </div>
            <div class="panel" id="sound-panel" onclick="toggleSound()">
                <h3>Sound</h3>
                <span id="sound-status">OFF</span>
            </div>
        </div>
    </div>

    <script>
        /**
         * 輕盈呼吸感音效管理器
         */
        const Sound = {
            ctx: null,
            muted: true,
            bgmTimer: null,
            noiseBuffer: null,

            init: function() {
                if (!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (AudioContext) {
                        this.ctx = new AudioContext();
                        this.createNoiseBuffer();
                    }
                }
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume().catch(e => console.log(e));
                }
            },

            createNoiseBuffer: function() {
                if (!this.ctx) return;
                const bufferSize = this.ctx.sampleRate * 2; 
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                this.noiseBuffer = buffer;
            },

            toggle: function() {
                this.muted = !this.muted;
                if (!this.muted) {
                    this.init();
                    this.startBGM(); 
                } else {
                    this.stopBGM(); 
                }
                return this.muted;
            },

            startBGM: function() {
                if (this.bgmTimer) return; 

                const playLoop = () => {
                    if (this.muted) return;
                    
                    const notes = [261.63, 329.63, 392.00, 493.88, 523.25, 659.25, 783.99];
                    
                    const count = 1 + Math.floor(Math.random() * 2);
                    
                    for(let i=0; i<count; i++) {
                        const note = notes[Math.floor(Math.random() * notes.length)];
                        setTimeout(() => this.playAmbientNote(note), Math.random() * 500);
                    }

                    const nextTime = 4000 + Math.random() * 4000; 
                    this.bgmTimer = setTimeout(playLoop, nextTime);
                };

                playLoop();
            },

            playAmbientNote: function(freq) {
                if (!this.ctx || this.muted) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'sine'; 
                osc.frequency.value = freq;
                
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.05, t + 2.0); 
                gain.gain.exponentialRampToValueAtTime(0.001, t + 6); 
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                
                osc.start(t);
                osc.stop(t + 6);
            },

            stopBGM: function() {
                if (this.bgmTimer) {
                    clearTimeout(this.bgmTimer);
                    this.bgmTimer = null;
                }
            },

            playMove: function() {
               return; 
            },

            // 修改後的落地聲：根據顏色改變音高 (Pitch/Scale)
            // colorId: 1(Red), 2(Green), 3(Blue), 4(Yellow)
            playDrop: function(colorId) {
                if (this.muted || !this.ctx || !this.noiseBuffer) return;
                const t = this.ctx.currentTime;
                
                const source = this.ctx.createBufferSource();
                source.buffer = this.noiseBuffer;
                
                // --- 音高映射邏輯 ---
                // 使用 playbackRate 來改變沙子聲的"音調" (速度越快，聲音越尖銳)
                // 1. 楓紅 (Low): 0.8
                // 2. 苔綠 (Mid): 1.0
                // 3. 青岩 (High): 1.2
                // 4. 暖沙 (Highest): 1.4
                // 預設值 1.0 (如果 colorId 異常)
                const pitches = [1.0, 0.8, 1.0, 1.2, 1.4]; 
                const pitch = pitches[colorId] || 1.0;
                
                source.playbackRate.value = pitch;

                // 根據音高稍微調整濾波器，讓低音更悶，高音更亮
                const baseFreq = 3500;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass'; 
                filter.frequency.value = baseFreq * pitch; 

                const gain = this.ctx.createGain();
                
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.015, t + 0.2); 
                gain.gain.exponentialRampToValueAtTime(0.001, t + 1.0); 

                source.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                
                source.start(t);
                source.stop(t + 1.0);
            },

            playClear: function() {
                if (this.muted || !this.ctx) return;
                const t = this.ctx.currentTime;
                const notes = [523.25, 659.25, 783.99, 1046.50];
                
                notes.forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    const startTime = t + (i * 0.08); 
                    
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(0.04, startTime + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.8);
                    
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);
                    osc.start(startTime);
                    osc.stop(startTime + 0.8);
                });
            },

            playGameOver: function() {
                if (this.muted || !this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(220, t);
                osc.frequency.linearRampToValueAtTime(55, t + 1.5);
                
                gain.gain.setValueAtTime(0.15, t);
                gain.gain.linearRampToValueAtTime(0, t + 1.5);
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(t);
                osc.stop(t + 1.5);
            }
        };

        function toggleSound() {
            const isMuted = Sound.toggle();
            const panel = document.getElementById('sound-panel');
            const status = document.getElementById('sound-status');
            
            if (!isMuted) {
                panel.classList.add('active');
                status.innerText = "ON";
            } else {
                panel.classList.remove('active');
                status.innerText = "OFF";
            }
            document.getElementById('gameCanvas').focus();
        }

        /**
         * 遊戲配置 - Loft 自然版
         */
        const CELL_SIZE = 5; 
        const COLS = 100;          
        const ROWS = 150; 
        const BLOCK_SCALE = 6; 
        
        // 速度調整
        const INITIAL_SPEED = 80;  
        const SPEED_INCREMENT = 1; 
        const LOCK_DELAY = 800;    

        // 山景沙畫配色 (Landscape Palette) - 秋意版
        const COLORS = [
            null,
            // 1. 楓紅 (Maple Red) - 取代原本深不可見的深綠，增加秋意
            ['#E69A8D', '#D16D5A', '#A64B3C'], 
            // 2. 苔蘚綠 (Bright Moss) - 明亮的植被
            ['#A8C686', '#87A860', '#638042'], 
            // 3. 青岩灰 (Slate Green) - 山石與霧氣
            ['#8FB8CA', '#6D94A6', '#4F7080'], 
            // 4. 暖沙褐 (Warm Earth) - 土地與樹幹 (點綴色)
            ['#D4B499', '#B59275', '#8F7056'], 
        ];

        const RAW_SHAPES = [
            [],
            [[0, 1, 0], [1, 1, 1], [0, 0, 0]], // T
            [[0, 1, 1], [1, 1, 0], [0, 0, 0]], // S
            [[1, 1, 0], [0, 1, 1], [0, 0, 0]], // Z
            [[0, 0, 1], [1, 1, 1], [0, 0, 0]], // L
            [[1, 1], [1, 1]], // O
            [[1, 0, 0], [1, 1, 1], [0, 0, 0]]  // J
        ];

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const nextCanvas = document.getElementById('nextCanvas');
        const nextCtx = nextCanvas.getContext('2d');

        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const gameOverScreen = document.getElementById('game-over');

        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');
        const btnDown = document.getElementById('btn-down');

        canvas.width = COLS * CELL_SIZE;
        canvas.height = ROWS * CELL_SIZE;

        let grid = []; 
        let player = null; 
        let nextPiece = null;

        let dropCounter = 0;
        let dropInterval = INITIAL_SPEED;
        let lastTime = 0;
        let score = 0;
        let level = 1;
        let isGameOver = false;
        
        let lockTimer = 0;
        let isTouchingGround = false;

        function createGrid() {
            return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        }

        function scaleMatrix(matrix, scale) {
            const newRows = matrix.length * scale;
            const newCols = matrix[0].length * scale;
            const newMatrix = [];

            for (let y = 0; y < newRows; y++) {
                const row = [];
                for (let x = 0; x < newCols; x++) {
                    const srcY = Math.floor(y / scale);
                    const srcX = Math.floor(x / scale);
                    if (srcY < matrix.length && srcX < matrix[0].length) {
                        row.push(matrix[srcY][srcX]);
                    } else {
                        row.push(0);
                    }
                }
                newMatrix.push(row);
            }
            return newMatrix;
        }

        function createPiece() {
            const typeId = (Math.random() * 6 | 0) + 1;
            const baseShape = RAW_SHAPES[typeId];
            const colorId = (Math.random() * 4 | 0) + 1;
            const scaledShape = scaleMatrix(baseShape, BLOCK_SCALE);
            
            for(let y = 0; y < scaledShape.length; y++) {
                for(let x = 0; x < scaledShape[y].length; x++) {
                    if (scaledShape[y][x] !== 0) {
                        scaledShape[y][x] = colorId;
                    }
                }
            }
            
            return {
                matrix: scaledShape,
                pos: { x: (COLS / 2 | 0) - (scaledShape[0].length / 2 | 0), y: 0 },
                colorId: colorId
            };
        }

        function collide(arena, piece, offsetX = 0, offsetY = 0) {
            const [m, o] = [piece.matrix, piece.pos];
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 &&
                        (arena[y + o.y + offsetY] && arena[y + o.y + offsetY][x + o.x + offsetX]) !== 0) {
                        return true;
                    }
                }
            }
            return false;
        }

        function drawMatrix(matrix, offset, context = ctx) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        const globalX = x + offset.x;
                        const globalY = y + offset.y;
                        const noise = (Math.abs(globalX * 37 + globalY * 17)) % 3;
                        
                        context.fillStyle = COLORS[value][noise];
                        context.fillRect(
                            globalX * CELL_SIZE,
                            globalY * CELL_SIZE,
                            CELL_SIZE, CELL_SIZE
                        );
                    }
                });
            });
        }

        function drawNextPiece() {
            // 預覽背景色
            nextCtx.fillStyle = '#121413'; 
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

            if (!nextPiece) return;

            const pieceWidth = nextPiece.matrix[0].length * CELL_SIZE;
            const pieceHeight = nextPiece.matrix.length * CELL_SIZE;
            
            const offsetX = (nextCanvas.width - pieceWidth) / 2 / CELL_SIZE;
            const offsetY = (nextCanvas.height - pieceHeight) / 2 / CELL_SIZE;

            drawMatrix(nextPiece.matrix, {x: offsetX | 0, y: offsetY | 0}, nextCtx);
        }

        function draw() {
            // 主畫面背景
            ctx.fillStyle = '#121413';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawMatrix(grid, { x: 0, y: 0 });

            if (player) {
                const occupiedCols = new Set();
                player.matrix.forEach((row) => {
                    row.forEach((val, x) => {
                        if (val !== 0) occupiedCols.add(x);
                    });
                });

                const startY = player.pos.y * CELL_SIZE;
                const endY = canvas.height;
                const beamHeight = endY - startY;

                const gradient = ctx.createLinearGradient(0, startY, 0, endY);
                // 調整光束顏色為極淡的暖白色
                gradient.addColorStop(0, 'rgba(230, 220, 210, 0.08)');   
                gradient.addColorStop(1, 'rgba(230, 220, 210, 0)');     

                ctx.fillStyle = gradient;
                
                occupiedCols.forEach(colOffset => {
                    const x = (player.pos.x + colOffset) * CELL_SIZE;
                    ctx.fillRect(x, startY, CELL_SIZE, beamHeight);
                });

                drawMatrix(player.matrix, player.pos);
            }
        }

        function merge(arena, piece) {
            // 傳入 colorId 以觸發不同音高
            Sound.playDrop(piece.colorId); 
            piece.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        const targetY = y + piece.pos.y;
                        const targetX = x + piece.pos.x;
                        if (targetY >= 0 && targetY < ROWS && targetX >= 0 && targetX < COLS) {
                            arena[targetY][targetX] = value;
                        }
                    }
                });
            });
        }

        function updateSandPhysics() {
            for (let y = ROWS - 2; y >= 0; y--) {
                for (let x = 0; x < COLS; x++) {
                    const pixel = grid[y][x];
                    if (pixel === 0) continue;

                    if (grid[y + 1][x] === 0) {
                        grid[y + 1][x] = pixel;
                        grid[y][x] = 0;
                    } 
                    else {
                        const dir = Math.random() > 0.5 ? 1 : -1;
                        const sideA = x + dir;
                        const sideB = x - dir;

                        if (sideA >= 0 && sideA < COLS && grid[y + 1][sideA] === 0) {
                            grid[y + 1][sideA] = pixel;
                            grid[y][x] = 0;
                        } else if (sideB >= 0 && sideB < COLS && grid[y + 1][sideB] === 0) {
                            grid[y + 1][sideB] = pixel;
                            grid[y][x] = 0;
                        }
                    }
                }
            }
        }

        function checkMatches() {
            let visited = new Uint8Array(ROWS * COLS); 
            let pixelsToRemove = [];
            let matchFound = false;

            for (let y = 0; y < ROWS; y++) {
                let startIdx = y * COLS + 0;
                
                if (grid[y][0] !== 0 && visited[startIdx] === 0) {
                    let color = grid[y][0];
                    let queue = [ {x:0, y:y} ];
                    let currentBlob = []; 
                    let reachedRight = false; 
                    
                    visited[startIdx] = 1;

                    let head = 0;
                    while(head < queue.length) {
                        let curr = queue[head++];
                        currentBlob.push(curr);

                        if (curr.x === COLS - 1) {
                            reachedRight = true;
                        }

                        const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                        for (let i = 0; i < 4; i++) {
                            let nx = curr.x + dirs[i][0];
                            let ny = curr.y + dirs[i][1];

                            if (ny >= 0 && ny < ROWS && nx >= 0 && nx < COLS) {
                                let idx = ny * COLS + nx;
                                if (visited[idx] === 0 && grid[ny][nx] === color) {
                                    visited[idx] = 1;
                                    queue.push({x: nx, y: ny});
                                }
                            }
                        }
                    }

                    if (reachedRight) {
                        pixelsToRemove.push(...currentBlob);
                        matchFound = true;
                    }
                }
            }

            if (matchFound) {
                Sound.playClear(); 
                for (let i = 0; i < pixelsToRemove.length; i++) {
                    let p = pixelsToRemove[i];
                    grid[p.y][p.x] = 0; 
                }
                score += pixelsToRemove.length * 10;
                scoreEl.innerText = score;
                
                if (score > level * 1000) {
                    level++;
                    levelEl.innerText = level;
                    dropInterval = Math.max(10, INITIAL_SPEED - (level * SPEED_INCREMENT));
                }
            }
        }

        function playerReset() {
            if (nextPiece === null) {
                nextPiece = createPiece();
            }

            player = nextPiece;
            nextPiece = createPiece();
            drawNextPiece();

            lockTimer = 0;
            isTouchingGround = false;

            if (collide(grid, player)) {
                isGameOver = true;
                Sound.playGameOver(); 
                Sound.stopBGM(); 
                gameOverScreen.style.visibility = 'visible';
            }
        }

        function playerDrop(deltaTime = 0) {
            if (collide(grid, player, 0, 1)) {
                isTouchingGround = true;
                lockTimer += deltaTime;

                if (lockTimer > LOCK_DELAY || deltaTime === -1) {
                    merge(grid, player);
                    playerReset();
                }
            } else {
                player.pos.y++;
                isTouchingGround = false;
                lockTimer = 0;
                dropCounter = 0;
            }
        }

        function playerMove(dir) {
            player.pos.x += dir;
            if (collide(grid, player)) {
                player.pos.x -= dir;
            } else {
                Sound.playMove(); 
                if (isTouchingGround) {
                    lockTimer = 0;
                }
            }
        }

        function update(time = 0) {
            if (isGameOver) return;

            const deltaTime = time - lastTime;
            lastTime = time;

            dropCounter += deltaTime;
            
            if (dropCounter > dropInterval) {
                playerDrop(dropInterval);
            } else if (isTouchingGround) {
                lockTimer += deltaTime;
                if (lockTimer > LOCK_DELAY) {
                    merge(grid, player);
                    playerReset();
                }
            }

            for(let i=0; i<5; i++) {
                updateSandPhysics();
            }
            
            checkMatches();

            draw();
            requestAnimationFrame(update);
        }

        function handleInput(key) {
             Sound.init();

             if (isGameOver) return;
             switch (key) {
                case 'ArrowLeft':
                case 'Left': 
                    playerMove(-1);
                    break;
                case 'ArrowRight':
                case 'Right':
                    playerMove(1);
                    break;
                case 'ArrowDown':
                case 'Down':
                    while (!collide(grid, player, 0, 1)) {
                        player.pos.y++;
                    }
                    playerDrop(-1); 
                    break;
            }
        }

        const bindButton = (btn, key) => {
            const action = (e) => {
                e.preventDefault();
                Sound.init();
                handleInput(key);
            };
            btn.addEventListener('mousedown', action);
            btn.addEventListener('touchstart', action);
        };

        bindButton(btnLeft, 'ArrowLeft');
        bindButton(btnRight, 'ArrowRight');
        bindButton(btnDown, 'ArrowDown');

        canvas.addEventListener('click', () => {
            canvas.focus();
        });

        canvas.addEventListener('keydown', event => {
            handleInput(event.key);
            if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(event.code) > -1) {
                event.preventDefault();
            }
        });

        document.addEventListener('keydown', event => {
            if (document.activeElement !== canvas) {
                handleInput(event.key);
            }
        });

        function resetGame() {
            grid = createGrid();
            score = 0;
            level = 1;
            scoreEl.innerText = score;
            levelEl.innerText = level;
            dropInterval = INITIAL_SPEED;
            isGameOver = false;
            gameOverScreen.style.visibility = 'hidden';
            
            nextPiece = null; 
            playerReset();
            
            canvas.focus();
            if(!Sound.muted) Sound.startBGM(); 
            update();
        }

        grid = createGrid();
        playerReset();
        canvas.focus();
        update();

    </script>
</body>
</html>