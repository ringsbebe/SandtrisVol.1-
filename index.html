<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sandtris - Mobile Optimized</title>
    <style>
        body {
            background-color: #1e2120; 
            color: #dcd3cb;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none; 
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        h1 {
            margin: 5px 0 10px 0;
            font-size: 24px;
            color: #a8c686; 
            text-shadow: 2px 2px 0px #0f1211;
            letter-spacing: 3px;
            font-weight: 300;
        }

        /* 主佈局容器 */
        #main-layout {
            display: flex;
            flex-direction: row;
            gap: 20px;
            align-items: flex-start;
            justify-content: center;
            width: 100%;
            max-width: 800px;
            height: 100%; /* 確保填滿 */
        }

        /* 遊戲區域 */
        #game-area {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #game-container {
            position: relative;
            border: 4px solid #3e4a42; 
            box-shadow: 0 0 30px rgba(0,0,0,0.6);
            background-color: #121413;
            height: 75vh; 
            aspect-ratio: 2 / 3;
            border-radius: 4px;
        }

        canvas#gameCanvas {
            display: block;
            background-color: #121413;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            outline: none;
            border-radius: 2px;
        }

        /* 側邊欄 (桌機版) */
        #sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 120px;
            padding-top: 20px;
        }

        .panel {
            background-color: #2a302d; 
            border: 1px solid #3e4a42;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }

        .panel h3 {
            margin: 0 0 5px 0;
            font-size: 12px;
            color: #7a8f80;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .panel span {
            font-size: 18px;
            font-weight: 500;
            color: #dcd3cb;
            display: block;
        }

        #sound-panel {
            cursor: pointer;
        }
        
        #sound-panel:hover {
            background-color: #353e39;
        }

        #sound-panel.active {
            border-color: #D16D5A; 
            background-color: #2e2524;
        }
        
        #sound-panel.active span {
            color: #D16D5A;
        }

        #nextCanvas {
            background-color: #121413;
            margin: 0 auto;
            display: block;
            border: 1px solid #2a302d;
            image-rendering: pixelated;
            max-width: 100%;
            border-radius: 4px;
        }

        #controls-hint {
            margin-top: 15px;
            font-size: 13px;
            color: #5a665e;
            text-align: center;
            width: 100%;
            font-weight: 300;
        }
        
        .key {
            display: inline-block;
            padding: 1px 6px;
            border: 1px solid #4a554e;
            border-radius: 4px;
            background: #2a302d;
            color: #b0c4b5;
            margin: 0 2px;
            font-family: monospace;
            font-size: 11px;
        }

        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(18, 20, 19, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            visibility: hidden;
            z-index: 10;
        }

        #game-over h2 {
            font-size: 32px;
            color: #D16D5A; 
            margin: 0 0 20px 0;
            font-weight: 300;
            letter-spacing: 2px;
        }

        button {
            padding: 10px 25px;
            font-size: 16px;
            cursor: pointer;
            background: #D16D5A; 
            border: none;
            border-radius: 20px;
            font-weight: 600;
            color: #121413;
            transition: transform 0.2s, background 0.2s;
            letter-spacing: 1px;
        }

        button:hover {
            transform: scale(1.05);
            background: #E69A8D;
        }

        button:active {
            transform: scale(0.95);
        }

        /* --- 手機版虛擬按鍵 (預設隱藏) --- */
        #mobile-controls {
            display: none; 
        }

        .control-btn {
            background: rgba(168, 198, 134, 0.1);
            border: 1px solid rgba(168, 198, 134, 0.3);
            border-radius: 12px;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #a8c686;
            user-select: none;
            cursor: pointer;
            transition: background 0.1s;
            margin: 5px 0; /* 垂直間距 */
        }

        .control-btn:active {
            background: rgba(168, 198, 134, 0.4);
            border-color: #a8c686;
            color: #fff;
        }

        /* --- RWD 響應式調整 (針對手機直式) --- */
        @media (max-width: 768px) {
            h1 {
                display: none; /* 手機版隱藏標題以節省空間 */
            }

            body {
                justify-content: flex-start;
                padding-top: 10px;
            }

            #main-layout {
                flex-direction: column;
                align-items: center;
                gap: 5px;
                height: 100%;
            }

            /* 手機版頂部資訊列 (原本的 Sidebar) */
            #sidebar {
                flex-direction: row;
                width: 95%;
                justify-content: space-between;
                gap: 5px;
                padding-top: 0;
                order: 1; /* 放在最上面 */
            }

            .panel {
                padding: 4px 8px;
                min-width: auto;
                flex: 1;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
            }
            
            .panel h3 {
                font-size: 10px;
                margin-bottom: 2px;
            }
            
            .panel span {
                font-size: 14px;
            }

            #nextCanvas {
                width: 25px;
                height: 25px;
            }

            /* 手機版遊戲主區域 */
            #game-area {
                order: 2; /* 放在中間 */
                flex-direction: row; /* 改為橫向排列：左遊戲，右按鈕 */
                width: 98%;
                height: 80vh; /* 佔據大部分高度 */
                align-items: center;
                justify-content: space-between;
            }

            #game-container {
                height: 100%;
                /* 寬度自動適應比例 */
                width: auto; 
                max-width: 75%; /* 留空間給右邊按鈕 */
                border-width: 2px;
            }

            #controls-hint {
                display: none;
            }

            /* 手機版按鈕區域 */
            #mobile-controls {
                display: flex;
                flex-direction: column; /* 垂直排列 */
                justify-content: center;
                align-items: center;
                width: 20%; /* 佔據右側空間 */
                height: 100%;
                gap: 10px;
            }

            .control-btn {
                width: 55px;
                height: 55px;
                font-size: 20px;
            }
            
            /* 調整按鈕順序：上(左) 中(右) 下(下) 或符合人體工學 */
            /* 這裡使用：上=左, 中=右, 下=下 */
        }
    </style>
</head>
<body>

    <h1>SANDTRIS</h1>

    <div id="main-layout">
        <div id="sidebar">
            <div class="panel">
                <h3>Next</h3>
                <canvas id="nextCanvas" width="120" height="120"></canvas>
            </div>
            <div class="panel">
                <h3>Score</h3>
                <span id="score">0</span>
            </div>
            <div class="panel">
                <h3>Level</h3>
                <span id="level">1</span>
            </div>
            <div class="panel" id="sound-panel" onclick="toggleSound()">
                <h3>Sound</h3>
                <span id="sound-status">OFF</span>
            </div>
        </div>

        <div id="game-area">
            <div id="game-container">
                <canvas id="gameCanvas" tabindex="1"></canvas>
                <div id="game-over">
                    <h2>GAME OVER</h2>
                    <button onclick="resetGame()">AGAIN</button>
                </div>
            </div>
            
            <div id="mobile-controls">
                <!-- 垂直排列：左、右、下 -->
                <div class="control-btn" id="btn-left">←</div>
                <div class="control-btn" id="btn-right">→</div>
                <div class="control-btn" id="btn-down" style="margin-top: 20px;">↓</div>
            </div>

            <div id="controls-hint">
                <span class="key">←</span> <span class="key">→</span> 移動 | 
                <span class="key">↓</span> 輕放
            </div>
        </div>
    </div>

    <script>
        // ... (音效代碼 Sound 對象保持不變) ...
        const Sound = {
            ctx: null,
            muted: true,
            bgmTimer: null,
            noiseBuffer: null,

            init: function() {
                if (!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (AudioContext) {
                        this.ctx = new AudioContext();
                        this.createNoiseBuffer();
                    }
                }
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume().catch(e => console.log(e));
                }
            },

            createNoiseBuffer: function() {
                if (!this.ctx) return;
                const bufferSize = this.ctx.sampleRate * 2; 
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                this.noiseBuffer = buffer;
            },

            toggle: function() {
                this.muted = !this.muted;
                if (!this.muted) {
                    this.init();
                    this.startBGM(); 
                } else {
                    this.stopBGM(); 
                }
                return this.muted;
            },

            startBGM: function() {
                if (this.bgmTimer) return; 

                const playLoop = () => {
                    if (this.muted) return;
                    const notes = [261.63, 329.63, 392.00, 493.88, 523.25, 659.25, 783.99];
                    const count = 1 + Math.floor(Math.random() * 2);
                    for(let i=0; i<count; i++) {
                        const note = notes[Math.floor(Math.random() * notes.length)];
                        setTimeout(() => this.playAmbientNote(note), Math.random() * 500);
                    }
                    const nextTime = 4000 + Math.random() * 4000; 
                    this.bgmTimer = setTimeout(playLoop, nextTime);
                };
                playLoop();
            },

            playAmbientNote: function(freq) {
                if (!this.ctx || this.muted) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine'; 
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.05, t + 2.0); 
                gain.gain.exponentialRampToValueAtTime(0.001, t + 6); 
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(t);
                osc.stop(t + 6);
            },

            stopBGM: function() {
                if (this.bgmTimer) {
                    clearTimeout(this.bgmTimer);
                    this.bgmTimer = null;
                }
            },

            playMove: function() { return; },

            playDrop: function(colorId) {
                if (this.muted || !this.ctx || !this.noiseBuffer) return;
                const t = this.ctx.currentTime;
                const source = this.ctx.createBufferSource();
                source.buffer = this.noiseBuffer;
                const pitches = [1.0, 0.8, 1.0, 1.2, 1.4]; 
                const pitch = pitches[colorId] || 1.0;
                source.playbackRate.value = pitch;
                const baseFreq = 3500;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass'; 
                filter.frequency.value = baseFreq * pitch; 
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.015, t + 0.2); 
                gain.gain.exponentialRampToValueAtTime(0.001, t + 1.0); 
                source.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                source.start(t);
                source.stop(t + 1.0);
            },

            playClear: function() {
                if (this.muted || !this.ctx) return;
                const t = this.ctx.currentTime;
                const notes = [523.25, 659.25, 783.99, 1046.50];
                notes.forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    const startTime = t + (i * 0.08); 
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(0.04, startTime + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.8);
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);
                    osc.start(startTime);
                    osc.stop(startTime + 0.8);
                });
            },

            playGameOver: function() {
                if (this.muted || !this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(220, t);
                osc.frequency.linearRampToValueAtTime(55, t + 1.5);
                gain.gain.setValueAtTime(0.15, t);
                gain.gain.linearRampToValueAtTime(0, t + 1.5);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(t);
                osc.stop(t + 1.5);
            }
        };

        function toggleSound() {
            const isMuted = Sound.toggle();
            const panel = document.getElementById('sound-panel');
            const status = document.getElementById('sound-status');
            if (!isMuted) {
                panel.classList.add('active');
                status.innerText = "ON";
            } else {
                panel.classList.remove('active');
                status.innerText = "OFF";
            }
            document.getElementById('gameCanvas').focus();
        }

        // ... (遊戲核心配置不變) ...
        const CELL_SIZE = 5; 
        const COLS = 100;          
        const ROWS = 150; 
        const BLOCK_SCALE = 6; 
        const INITIAL_SPEED = 80;  
        const SPEED_INCREMENT = 1; 
        const LOCK_DELAY = 800;    

        const COLORS = [
            null,
            ['#E69A8D', '#D16D5A', '#A64B3C'], 
            ['#A8C686', '#87A860', '#638042'], 
            ['#8FB8CA', '#6D94A6', '#4F7080'], 
            ['#D4B499', '#B59275', '#8F7056'], 
        ];

        const RAW_SHAPES = [
            [],
            [[0, 1, 0], [1, 1, 1], [0, 0, 0]], 
            [[0, 1, 1], [1, 1, 0], [0, 0, 0]], 
            [[1, 1, 0], [0, 1, 1], [0, 0, 0]], 
            [[0, 0, 1], [1, 1, 1], [0, 0, 0]], 
            [[1, 1], [1, 1]], 
            [[1, 0, 0], [1, 1, 1], [0, 0, 0]]  
        ];

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextCanvas');
        const nextCtx = nextCanvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const gameOverScreen = document.getElementById('game-over');
        
        // 虛擬按鍵
        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');
        const btnDown = document.getElementById('btn-down');

        canvas.width = COLS * CELL_SIZE;
        canvas.height = ROWS * CELL_SIZE;

        let grid = []; 
        let player = null; 
        let nextPiece = null;
        let dropCounter = 0;
        let dropInterval = INITIAL_SPEED;
        let lastTime = 0;
        let score = 0;
        let level = 1;
        let isGameOver = false;
        let lockTimer = 0;
        let isTouchingGround = false;

        // ... (createGrid, scaleMatrix, createPiece 等 helper 函數保持不變) ...
        function createGrid() { return Array.from({ length: ROWS }, () => Array(COLS).fill(0)); }
        function scaleMatrix(matrix, scale) {
            const newRows = matrix.length * scale;
            const newCols = matrix[0].length * scale;
            const newMatrix = [];
            for (let y = 0; y < newRows; y++) {
                const row = [];
                for (let x = 0; x < newCols; x++) {
                    const srcY = Math.floor(y / scale);
                    const srcX = Math.floor(x / scale);
                    if (srcY < matrix.length && srcX < matrix[0].length) {
                        row.push(matrix[srcY][srcX]);
                    } else {
                        row.push(0);
                    }
                }
                newMatrix.push(row);
            }
            return newMatrix;
        }
        function createPiece() {
            const typeId = (Math.random() * 6 | 0) + 1;
            const baseShape = RAW_SHAPES[typeId];
            const colorId = (Math.random() * 4 | 0) + 1;
            const scaledShape = scaleMatrix(baseShape, BLOCK_SCALE);
            for(let y = 0; y < scaledShape.length; y++) {
                for(let x = 0; x < scaledShape[y].length; x++) {
                    if (scaledShape[y][x] !== 0) scaledShape[y][x] = colorId;
                }
            }
            return { matrix: scaledShape, pos: { x: (COLS / 2 | 0) - (scaledShape[0].length / 2 | 0), y: 0 }, colorId: colorId };
        }
        function collide(arena, piece, offsetX = 0, offsetY = 0) {
            const [m, o] = [piece.matrix, piece.pos];
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 && (arena[y + o.y + offsetY] && arena[y + o.y + offsetY][x + o.x + offsetX]) !== 0) return true;
                }
            }
            return false;
        }
        function drawMatrix(matrix, offset, context = ctx) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        const globalX = x + offset.x;
                        const globalY = y + offset.y;
                        const noise = (Math.abs(globalX * 37 + globalY * 17)) % 3;
                        context.fillStyle = COLORS[value][noise];
                        context.fillRect(globalX * CELL_SIZE, globalY * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                });
            });
        }
        function drawNextPiece() {
            nextCtx.fillStyle = '#121413'; 
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            if (!nextPiece) return;
            const pieceWidth = nextPiece.matrix[0].length * CELL_SIZE;
            const pieceHeight = nextPiece.matrix.length * CELL_SIZE;
            const offsetX = (nextCanvas.width - pieceWidth) / 2 / CELL_SIZE;
            const offsetY = (nextCanvas.height - pieceHeight) / 2 / CELL_SIZE;
            drawMatrix(nextPiece.matrix, {x: offsetX | 0, y: offsetY | 0}, nextCtx);
        }
        function draw() {
            ctx.fillStyle = '#121413';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawMatrix(grid, { x: 0, y: 0 });
            if (player) {
                const occupiedCols = new Set();
                player.matrix.forEach((row) => {
                    row.forEach((val, x) => { if (val !== 0) occupiedCols.add(x); });
                });
                const startY = player.pos.y * CELL_SIZE;
                const endY = canvas.height;
                const beamHeight = endY - startY;
                const gradient = ctx.createLinearGradient(0, startY, 0, endY);
                gradient.addColorStop(0, 'rgba(230, 220, 210, 0.08)');   
                gradient.addColorStop(1, 'rgba(230, 220, 210, 0)');     
                ctx.fillStyle = gradient;
                occupiedCols.forEach(colOffset => {
                    const x = (player.pos.x + colOffset) * CELL_SIZE;
                    ctx.fillRect(x, startY, CELL_SIZE, beamHeight);
                });
                drawMatrix(player.matrix, player.pos);
            }
        }
        function merge(arena, piece) {
            Sound.playDrop(piece.colorId); 
            piece.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        const targetY = y + piece.pos.y;
                        const targetX = x + piece.pos.x;
                        if (targetY >= 0 && targetY < ROWS && targetX >= 0 && targetX < COLS) {
                            arena[targetY][targetX] = value;
                        }
                    }
                });
            });
        }
        function updateSandPhysics() {
            for (let y = ROWS - 2; y >= 0; y--) {
                for (let x = 0; x < COLS; x++) {
                    const pixel = grid[y][x];
                    if (pixel === 0) continue;
                    if (grid[y + 1][x] === 0) {
                        grid[y + 1][x] = pixel;
                        grid[y][x] = 0;
                    } else {
                        const dir = Math.random() > 0.5 ? 1 : -1;
                        const sideA = x + dir;
                        const sideB = x - dir;
                        if (sideA >= 0 && sideA < COLS && grid[y + 1][sideA] === 0) {
                            grid[y + 1][sideA] = pixel;
                            grid[y][x] = 0;
                        } else if (sideB >= 0 && sideB < COLS && grid[y + 1][sideB] === 0) {
                            grid[y + 1][sideB] = pixel;
                            grid[y][x] = 0;
                        }
                    }
                }
            }
        }
        function checkMatches() {
            let visited = new Uint8Array(ROWS * COLS); 
            let pixelsToRemove = [];
            let matchFound = false;
            for (let y = 0; y < ROWS; y++) {
                let startIdx = y * COLS + 0;
                if (grid[y][0] !== 0 && visited[startIdx] === 0) {
                    let color = grid[y][0];
                    let queue = [ {x:0, y:y} ];
                    let currentBlob = []; 
                    let reachedRight = false; 
                    visited[startIdx] = 1;
                    let head = 0;
                    while(head < queue.length) {
                        let curr = queue[head++];
                        currentBlob.push(curr);
                        if (curr.x === COLS - 1) reachedRight = true;
                        const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                        for (let i = 0; i < 4; i++) {
                            let nx = curr.x + dirs[i][0];
                            let ny = curr.y + dirs[i][1];
                            if (ny >= 0 && ny < ROWS && nx >= 0 && nx < COLS) {
                                let idx = ny * COLS + nx;
                                if (visited[idx] === 0 && grid[ny][nx] === color) {
                                    visited[idx] = 1;
                                    queue.push({x: nx, y: ny});
                                }
                            }
                        }
                    }
                    if (reachedRight) {
                        pixelsToRemove.push(...currentBlob);
                        matchFound = true;
                    }
                }
            }
            if (matchFound) {
                Sound.playClear(); 
                for (let i = 0; i < pixelsToRemove.length; i++) {
                    let p = pixelsToRemove[i];
                    grid[p.y][p.x] = 0; 
                }
                score += pixelsToRemove.length * 10;
                scoreEl.innerText = score;
                if (score > level * 1000) {
                    level++;
                    levelEl.innerText = level;
                    dropInterval = Math.max(10, INITIAL_SPEED - (level * SPEED_INCREMENT));
                }
            }
        }
        function playerReset() {
            if (nextPiece === null) nextPiece = createPiece();
            player = nextPiece;
            nextPiece = createPiece();
            drawNextPiece();
            lockTimer = 0;
            isTouchingGround = false;
            if (collide(grid, player)) {
                isGameOver = true;
                Sound.playGameOver(); 
                Sound.stopBGM(); 
                gameOverScreen.style.visibility = 'visible';
            }
        }
        function playerDrop(deltaTime = 0) {
            if (collide(grid, player, 0, 1)) {
                isTouchingGround = true;
                lockTimer += deltaTime;
                if (lockTimer > LOCK_DELAY || deltaTime === -1) {
                    merge(grid, player);
                    playerReset();
                }
            } else {
                player.pos.y++;
                isTouchingGround = false;
                lockTimer = 0;
                dropCounter = 0;
            }
        }
        function playerMove(dir) {
            player.pos.x += dir;
            if (collide(grid, player)) {
                player.pos.x -= dir;
            } else {
                Sound.playMove(); 
                if (isTouchingGround) lockTimer = 0;
            }
        }
        function update(time = 0) {
            if (isGameOver) return;
            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;
            if (dropCounter > dropInterval) playerDrop(dropInterval);
            else if (isTouchingGround) {
                lockTimer += deltaTime;
                if (lockTimer > LOCK_DELAY) {
                    merge(grid, player);
                    playerReset();
                }
            }
            for(let i=0; i<5; i++) updateSandPhysics();
            checkMatches();
            draw();
            requestAnimationFrame(update);
        }

        // --- 輸入控制與長按連發邏輯 ---
        function handleInput(key) {
             Sound.init();
             if (isGameOver) return;
             switch (key) {
                case 'ArrowLeft': playerMove(-1); break;
                case 'ArrowRight': playerMove(1); break;
                case 'ArrowDown': 
                    while (!collide(grid, player, 0, 1)) player.pos.y++;
                    playerDrop(-1); 
                    break;
            }
        }

        // 長按控制變數
        let inputInterval = null;
        let inputDelay = null;

        // 開始移動 (按下)
        const startAction = (key) => {
            // 防止重複觸發
            if (inputDelay || inputInterval) return;
            
            Sound.init();
            handleInput(key); // 立即執行一次

            // 設定延遲後的連發 (DAS - Delayed Auto Shift)
            // 200ms 後開始連發，每 80ms 移動一次
            inputDelay = setTimeout(() => {
                inputInterval = setInterval(() => {
                    handleInput(key);
                }, 80);
            }, 200);
        };

        // 停止移動 (放開)
        const stopAction = () => {
            clearTimeout(inputDelay);
            clearInterval(inputInterval);
            inputDelay = null;
            inputInterval = null;
        };

        // 綁定按鈕事件 (支援滑鼠與觸控)
        const bindButton = (btn, key) => {
            // 觸控開始
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault(); // 防止滾動與選取
                startAction(key);
            }, {passive: false});

            // 觸控結束/取消
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                stopAction();
            });
            btn.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                stopAction();
            });

            // 滑鼠按下 (桌機測試用)
            btn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startAction(key);
            });
            // 滑鼠放開/離開
            btn.addEventListener('mouseup', stopAction);
            btn.addEventListener('mouseleave', stopAction);
        };

        bindButton(btnLeft, 'ArrowLeft');
        bindButton(btnRight, 'ArrowRight');
        bindButton(btnDown, 'ArrowDown');

        canvas.addEventListener('click', () => { canvas.focus(); });
        canvas.addEventListener('keydown', event => {
            // 鍵盤仍維持單次觸發 (通常鍵盤自帶 repeat)
            handleInput(event.key);
            if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(event.code) > -1) event.preventDefault();
        });
        document.addEventListener('keydown', event => {
            if (document.activeElement !== canvas) handleInput(event.key);
        });

        function resetGame() {
            grid = createGrid();
            score = 0;
            level = 1;
            scoreEl.innerText = score;
            levelEl.innerText = level;
            dropInterval = INITIAL_SPEED;
            isGameOver = false;
            gameOverScreen.style.visibility = 'hidden';
            nextPiece = null; 
            playerReset();
            canvas.focus();
            if(!Sound.muted) Sound.startBGM(); 
            update();
        }

        grid = createGrid();
        playerReset();
        canvas.focus();
        update();

    </script>
</body>
</html>
